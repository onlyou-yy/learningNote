# 浏览器环境JavaScript的事件循环（Event Loop）

​		javascript是一门单线程的非阻塞的脚本语言，这是又其最初的用途来决定的：与浏览器交互。单线程也就意味着JavaScript在执行的时候都只有一个主线程来处理所有的任务。而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

​		虽然现在有web worker技术可以开多线程但是却有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。

​		那么js是如何实现非阻塞的呢？答案就是事件循环，事件循环简单来说是有时执行栈和任务队列组成。我们知道栈I/O就是先入后出，而任务队列中又有宏任务和微任务之分，任务的执行顺序是先执行微任务然后再执行宏任务。那么就可以有如下图的事例图

![1588876631182](事件循环/1588876631182.png)

​		JavaScript中我们调用一个函数或方法的时候是会创建对应的执行环境的，也就是执行上下文，这个执行环境会被放到事件循环的执行栈中，如果这个执行环境中有异步的函数的话，那么就会将这异步函数放到任务队列中，当这个函数执行完成（return了）之后这个执行环境（函数）就会被弹出执行栈，之后继续读后续的代码，当发现再有函数被调用时就会重复上面的操作。具体流程可以参考 [2分钟了解 JavaScript Event Loop | 面试必备](https://www.bilibili.com/video/BV1kf4y1U7Ln) 。

浏览器执行执行JavaScript的流程其实是这样的

```javascript
宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
```

之前不是所是先执行微任务再执行宏任务吗？为什么这里是先执行宏任务再执行微任务？

因为主代码块也是宏任务，第一次执行的宏任务其实就是主代码块，然后主代码模块执行完成之后就执行微任务了，如果忽略掉浏览器的GUI渲染步骤就是

```javascript
主代码块 -> 微任务  -> 宏任务 -> 微任务  -> 宏任务 -> ...
```

具体参考 [详解JavaScript中的Event Loop（事件循环）机制](https://www.cnblogs.com/cangqinglang/p/8967268.html) 

常见的宏任务：

- 主代码块
- setTimeout
- setInterval
- setImmediate ()-Node
- requestAnimationFrame ()-浏览器

常见微任务：

- process.nextTick ()-Node
- Promise.then()
  - Promise在定义的时候是立即执行的，定义时候的代码块部分也是属于宏任务
  - await后面的表达式最终会被处理成promise，且是未完成状态的微任务，会阻塞后面代码的执行
- catch
- finally
- Object.observe
- MutationObserver

来个题

```javascript
async function a1(){
  console.log(`a1 start`)
  await a2();
  console.log(`a1 end`)
}

async function a2(){
  console.log('a2')
}

console.log(`script start`)

setTimeout(()=>{
  console.log('settimeout');
},0)

Promise.resolve().then(()=>{
  console.log('promise1')
})

a1();

let promise2=new Promise(resolve=>{
  resolve('promis2.then')
  console.log('promise2')
})

promise2.then(res=>{
  console.log(res)
  Promise.resolve().then(()=>{
    console.log('promise3')
  })
})
console.log('script end')
```

​		首先执行的是主代码块，也就是先执行了11行`console.log('script start')`要入执行栈中输出‘script start’后弹出（下面的console.log都是要压入执行栈中，输出完成后被弹出）；然后读到`setTimeout()`压入执行栈中，setTimeout是宏任务将里面的代码`console.log('settimeout');`放入到宏任务队列中，弹出13行的`setTimeout()`；继续执行到17行`Promise.resolve().then()` 将`Promise.resolve()`压入执行栈中弹出，Promise的then和catch是微任务所以将`Promise.resolve().then()`压入执行栈，将`console.log('promise1')`放入到微任务队列中；继续执行a1函数（使用async标记的函数返回的是一个promise对象，函数里面相当于实例化Promise构造函数），将`a1()`压入执行栈中，执行`console.log('a1 start')`输出’a1 start‘，继续执行`await a2()`,将a2()压入执行栈，执行`console.log('a2')`输出a2，弹出a2()，但是await的结果是一个 `promise.then()` 阻塞后面代码的执行，将这个promise加入到微任务队列中，当这个promise完成后才会继续执行后续代码(`console.log('a1 end')`)；继续执行23行的代码，将`new Promise()`压入执行栈，将`resolve(‘promis2.then’)` 也压入执行栈完成后弹出，继续执行`console.log('promise2')`输出promise2将`new Promise()`弹出；继续执行28行`promise2.then()`将这个微任务放入到微任务队列中；最后执行`console.log('script end')`输出script end。到此主代码块执行完成

目前输出了

```shell
script start
a1 start
a2
promise2
script end
```

微任务队列

```javascript
Promise.resolve().then();//结果为promise1
promise.then()//a1中的await阻塞a1 end
promise2.then()//结果为promis2.then，Promise.resolve().then()//结果为promise3
```

宏任务队列

```javascript
setTimeout();//结果为settimeout
```

先执行微任务队列，当微任务队列中为空了再执行宏任务队列，结果为

```shell
script start
a1 start
a2
promise2
script end
promise1
a1 end
promise2.then
promise3
settimeout
```



参考文章和视频

[「硬核JS」一次搞懂JS运行机制](https://juejin.im/post/5e22b391f265da3e204d8c14)

[详解JavaScript中的Event Loop（事件循环）机制](https://www.cnblogs.com/cangqinglang/p/8967268.html)

[2分钟了解 JavaScript Event Loop | 面试必备](https://www.bilibili.com/video/BV1kf4y1U7Ln)

